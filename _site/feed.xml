<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>A shelter for a lazy and terrible programmer, loving photograph and travelling!</description>
    <link>http://shellcottage.me/</link>
    <atom:link href="http://shellcottage.me/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 22 Jun 2016 00:03:42 +0800</pubDate>
    <lastBuildDate>Wed, 22 Jun 2016 00:03:42 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>写在西浦别离时</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;我知道，有件事是一定的，正如我现在去看自己过去所思所写会觉得蠢到不行，未来的某一天，我看到自己现在所写也必然会觉得极为稚幼。但是那又有什么关系呢？不过是言为心声罢了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;6月，苏州的雨季，潮气像藤蔓一样蜿蜒着，让人无所适从。&lt;/p&gt;

&lt;p&gt;“烘托了悲凉的气氛”是语文阅读答卷里最常见的语汇之一，偶尔在现实里也很贴切。比如现在，雨中的西浦，搬家的学子是匆匆忙忙的。大四的各奔出路；大二大三留下来的要被强制搬到2公里开外的新宿舍；大二2去英国的一部分卷了铺盖儿回了家，一部分要搬去只住两个月的临时宿舍；大一党，大约也会有一部分受到牵连被强制办了宿舍。&lt;/p&gt;

&lt;p&gt;每个人都有自己的目的地。在其他大学放端午假顺便在高考的时候，我们便匆匆考了final，匆匆和周围人来得及或者并没有来得及地说了再见，匆匆吃了散伙饭，匆匆地见了或没有见到他或她的最后一面，匆匆放了暑假。匆匆地，只有背影能够被留下。对很多人来说，最后一次（也许是第一次，笑）见到某一个课的Lecturer，是在final的考场上；最后一次见到某个朋友，是在上一次不知道什么时候以前的聚会或者几天前自习的时候。就在刚才，去拜访有几个老友住着的7310宿舍，敲了敲门，已然无人回应。&lt;/p&gt;

&lt;p&gt;特别喜欢“一期一会，世当珍惜”的禅意，我是俗人，不懂茶道也不通佛法。但是活到现在，还是知道离别总是多于相聚的这个常理的。“时光的河入海流，终于我们分头走；没有哪个港口，是永远的停留。” 林同学这样唱到。聚散离合，是生命的常态；就如同生老病死是生命的常态一样。这种事情，虽然看起来悲凉，其实不过尔尔。河流总会分叉，宴会总会结束，指针总会指向下一个变量，人总会死亡。&lt;/p&gt;

&lt;p&gt;可是总是到了别离的时候，甚至分别以后，我们才会去怀念一段时光，或者一些人。&lt;/p&gt;

&lt;p&gt;/*大一的时候，&lt;/p&gt;

&lt;p&gt;在FB 1楼疯子般的闹过，发过传单，&lt;/p&gt;

&lt;p&gt;考线代的前一天晚上，在FB151陪着一群蚊子睡去，&lt;/p&gt;

&lt;p&gt;在每一层的大教室里听着郭爷爷的微积分睡着，&lt;/p&gt;

&lt;p&gt;在小教室里听LC老师讲着听起来很高大上可是并卵的EAP，&lt;/p&gt;

&lt;p&gt;488，科协的实验室&amp;amp;杂货铺。&lt;/p&gt;

&lt;p&gt;物理实验室，文科生也算进去过做了次实验。&lt;/p&gt;

&lt;p&gt;高大上的会议室，不知道我们的意见CC老师听进去多少，不过青团子真的好吃。&lt;/p&gt;

&lt;p&gt;6楼，想起某只小buddy被锁在里面（笑）&lt;/p&gt;

&lt;p&gt;大二&lt;/p&gt;

&lt;p&gt;图书馆&lt;/p&gt;

&lt;p&gt;在3楼睡着，然后冬天会被冻感冒&lt;/p&gt;

&lt;p&gt;9楼，有各种技术类书籍&lt;/p&gt;

&lt;p&gt;3楼的打印机是唯一全校可以打印彩印的地方，所以总是排起长队&lt;/p&gt;

&lt;p&gt;而且总卡纸，卡完还没人管&lt;/p&gt;

&lt;p&gt;而且界面是中文，对国际有人不太友好(某只外国妹子: “Fucking Chinese”)&lt;/p&gt;

&lt;p&gt;6楼是讨论和吃东西的好地方&lt;/p&gt;

&lt;p&gt;其实楼下的便利店也不错&lt;/p&gt;

&lt;p&gt;不知道西浦的图书馆什么时候可以做到不闭馆，这样就不用刷夜的时候找位置了&lt;/p&gt;

&lt;p&gt;G13和G23,其实好久都没去过，好久都没再碰过那些曾经热衷的，光鲜亮丽但却华而不实的活动。&lt;/p&gt;

&lt;p&gt;地下通道（本diao在这里见到了各种豪车，叹息，每辆都比我家底儿还贵啊）&lt;/p&gt;

&lt;p&gt;对西浦的安保表示担忧，原来在一个妹子的指引下从S栋潜入过CB，大半夜的。不过这条通道很方便，尤其下雨的时候。现在应该可以通南校区。&lt;/p&gt;

&lt;p&gt;SD 4楼机房&lt;/p&gt;

&lt;p&gt;这学期奋斗（住）了好长时间，见过24小时的校园。春天，凌晨4点，你能听到叽叽喳喳的鸟鸣。暴雨的时候，可以看着在建的南校区发呆。&lt;/p&gt;

&lt;p&gt;说住在这里，毫不夸张，附近有饮水机有厕所（而且有厕纸供应，笑），旁边是老师办公室（关爷爷每天早上6点半或七点都会到办公室，睡不醒的年轻人表示真心服。）；楼下不远有便利店；一楼有饮料贩售机；可以通宵；空调随便开，软件老旧了点（好用的ide编辑器要自己装，没有git真的也比较麻烦）但是硬件杠杠的（大屏幕，而且i7４核8G内存跑４个Linux虚拟机组个虚拟局域网真的不虚）；系里专用账号，所以基本不用担心没有机位…唯一的问题是电梯，感觉该修了，咯吱咯吱的容易出事故。&lt;/p&gt;

&lt;p&gt;不大的另一篇校区，樱花开了的时候很是漂亮。&lt;/p&gt;

&lt;p&gt;忘记吃饭的时候，午夜就会去学校附近的全家卖一份便当或者方便面填饱肚子。&lt;/p&gt;

&lt;p&gt;必须说得是，回头来看，西浦的课堂质量的确没达到我的预期，讲得东西很浅，有很多老师和助教非常之水；唯独好在自由时间多，以本专业为例，操作系统，算法，数据结构留了各种大坑但是有一个长长的暑假。大学里，大概最珍贵的是看起来用不完但其实转瞬即逝的时间。&lt;/p&gt;

&lt;p&gt;御膳房，这是家死贵限制时间还吃不饱的餐厅，但是我仍然觉得比巴菲要良心，至少附近没有比它更便宜的吃饭的地方了。*/&lt;/p&gt;

&lt;p&gt;太多舍不得。可是舍得的与舍不得的，最终也必须舍得。其实很多时候，我们不过是这样宽慰自己罢了，离别是常态。日复一日，有人的地方，就有无聊浮躁的朋友圈（或者类似的社交平台），还有离别。&lt;/p&gt;

&lt;p&gt;不如就这样结束这篇文章吧。天涯海角，请君安好。&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bye&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

</description>
        <pubDate>Thu, 09 Jun 2016 16:30:00 +0800</pubDate>
        <link>http://shellcottage.me/words-when-leaving-XJTLU/</link>
        <guid isPermaLink="true">http://shellcottage.me/words-when-leaving-XJTLU/</guid>
        
        <category>离别</category>
        
        
        <category>life</category>
        
      </item>
    
      <item>
        <title>关于加密，验证, SSL / TLS3.0的基础知识 [OS concepts 搬运工系列]</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/2016-05-29-os-notes-chapter-15/cover.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;&lt;strong&gt;写在前面&lt;/strong&gt; ：&lt;/h2&gt;

&lt;p&gt;作为一个初学的弱渣，写这篇东西完全是在当笔记做。&lt;/p&gt;

&lt;p&gt;我觉得我们这门课虽然叫Operating System Concepts,到不如说是安全基本知识入门（所以学啥完全取决于老师的方向和自己）。这部分大概预习了（雾。。）有一周，还是懵懂，不对的地方希望大家多多指教。课本用得是很经典的Abraham Sliberschatz，Peter Bear Galvin 和Greg Gagne 的 Operating System Concepts 9th Edition（也就是恐龙书）. （然而弱渣的我基本上是看中译第七版，翻译得一塌糊涂）刚好看到&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21255045&quot;&gt;知乎最近也在升级Https&lt;/a&gt;，感觉没有很好的答案去解释这些概念，所以就把自己在书上看到的记在这里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中文是我自己翻译的，不对准确性负责&lt;/strong&gt; ，自己的陋见用的是斜体。（时间有限，所以就选一部分啦，请参见原书Chapter 15。）&lt;/p&gt;

&lt;p&gt;版权归书籍原作者所有。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;encryption-&quot;&gt;&lt;strong&gt;Encryption 加密&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Because it solves a wide variety of communication security problems, encryption
is used frequently in many aspects of modern computing. It is used to send
messages securely across a network, as well as to protect database data,
files, and even entire disks from having their contents read by unauthorized
entities.
由于加密能解决很多通信领域的安全问题，它被广泛使用在现代计算的很多方面，包括在不同的网络间安全地发送消息以及避免数
据，文件乃至整个磁盘的内容被不合法的实体读取。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;所以加密是用来解决安全问题的一种手段，关于 &lt;strong&gt;安全问题&lt;/strong&gt; ，前面一小节有提过：&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Security, on the other hand, requires not only an adequate protection
system but also consideration of the external environment within which the
system operates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;也就是说安全既要考虑内部的保护问题（简单的说就是系统内部的访问权限控制）也要考虑系统外部环境的操作。反过来对系统的攻击（attack）集中在：&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Breach of confidentiality（保密性）,&lt;/p&gt;

  &lt;p&gt;Breach of integrity（完整性）,&lt;/p&gt;

  &lt;p&gt;Breach of availability（可用性，简单的说就是unauthorized destruction未被许可的破坏）,&lt;/p&gt;

  &lt;p&gt;Theft of service（偷窃服务, 即 unauthorized use of resources私自占有使用资源）,&lt;/p&gt;

  &lt;p&gt;Denial of service（拒绝服务）.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;回到 &lt;strong&gt;加密&lt;/strong&gt; 这个话题，&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An encryption algorithm enables the sender of a message to ensure that only a computer possessing a certain key can read the message, or ensure that the writer of data is the only reader of that data.
加密算法能够让一个消息的发送者确定只有那些拥有特定密钥的计算机能够读取这个消息，或者仅仅只有数据的写入者才能读取它。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;An encryption algorithm consists of the following components:
+A set K of keys.
+ A set M of messages.
+ A set C of ciphertexts.
+ An encrypting function E : K → (M→C). That is, for each k ∈ K, E&lt;sub&gt;k&lt;/sub&gt;  is a
function for generating ciphertexts from messages. Both E and E&lt;sub&gt;k&lt;/sub&gt; for any k
should be efficiently computable functions. Generally, E{k} is a randomized
mapping from messages to ciphertexts.
+ A decrypting function D : K → (C → M). That is, for each k ∈ K, D&lt;sub&gt;k&lt;/sub&gt; is a
function for generating messages from ciphertexts. Both D and D&lt;sub&gt;k&lt;/sub&gt; for any
k should be efficiently computable functions.&lt;/p&gt;

  &lt;p&gt;加密算法由下面部分构成：
+ 一个密钥集合K
+ 一个消息集合M
+ 一个密文集合C
+ 一个加密函数 E : K → (M→C). 即，对于每个密钥 k ∈ K, E&lt;sub&gt;k&lt;/sub&gt;是一个用消息生成密文的函数。对任意k来说， E 和 E&lt;sub&gt;k&lt;/sub&gt;都是高效的且可计算的函数。大致来说，E&lt;sub&gt;k&lt;/sub&gt; 是从消息到密文的一个随机映射。
+ 一个解密函数 E : K → (C→M). 即，对于每个密钥 k ∈ K, D&lt;sub&gt;k&lt;/sub&gt;是一个用密文生成消息的函数。对任意k来说， D 和 D&lt;sub&gt;k&lt;/sub&gt;都是高效的且可计算的函数。大致来说，D&lt;sub&gt;k&lt;/sub&gt;是从密文到消息的一个随机映射。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;An encryption algorithm must provide this essential property: given a
ciphertext c ∈ C, a computer can compute m such that E&lt;sub&gt;k&lt;/sub&gt;  (m) = c only if
it possesses k. Thus, a computer holding k can decrypt ciphertexts to the
plaintexts used to produce them, but a computer not holding k cannot decrypt
ciphertexts. Since ciphertexts are generally exposed (for example, sent on a
network), it is important that it be infeasible to derive k from the ciphertexts.
There are two main types of encryption algorithms: symmetric and
asymmetric.
 ** 一个加密算法必须提供这个必要属性：给定一个密文c ∈ 密文集合C， 只有计算机掌握k的时候才能通过计算加密函数E&lt;sub&gt;k&lt;/sub&gt; (m) = c得到消息m。**  因此，只有掌握密钥k的计算机可以解密密文，但是没有掌握k的计算机却不可以。因为密文常常是被暴露出来的（比如在网络中发送的时候），所以很重要的一点是让从密文推出密钥k变得不可能。一共有两种加密：对称加密和非对称加密。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;symmetric-encryption-algorithm-and-asymmetric-encryption-algorithm&quot;&gt;&lt;strong&gt;Symmetric encryption algorithm and Asymmetric encryption algorithm&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;strong&gt;对称加密：&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;In a symmetric encryption algorithm, the same key is used to encrypt and to
decrypt. Therefore, the secrecy of k must be protected.
对称加密算法使用同样的密钥来加密和解密，因此，必须使密钥k保持机密。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/2016-05-29-os-notes-chapter-15/15.7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;该图展示了用对称密钥加密的过程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;几种对称加密算法：&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;data-encryption standard (DES)：64-bit value,a 56-bit key, performing a series of transformations that are based on substitution and permutation operations &lt;em&gt;（基于替换和排列变换）&lt;/em&gt;. Work on a block of bits at a time, is known as a block cipher.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;triple DES: DES algorithm is repeated three times (two encryptions and one decryption) on the same plaintext using two or three keys—for example, c = E&lt;sub&gt;k&lt;sub&gt;3&lt;/sub&gt;&lt;/sub&gt; (D&lt;sub&gt;k&lt;sub&gt;2&lt;/sub&gt;&lt;/sub&gt; (E&lt;sub&gt;k&lt;sub&gt;1&lt;/sub&gt;&lt;/sub&gt; (m))). When three keys are used, the effective key length is 168 bits (i.e. 56*3).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;advanced encryption standard (AES)：another block cipher, use key lengths of 128, 192, or 256 bits and works on 128-bit blocks. * 这里block cipher应该是按照固定bit长度加密的意思 *&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;RC4: stream cipher based (encrypt and decrypt a stream of bytes or bits rather than a block). This is useful when the length of a communication would make a block cipher
too slow.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;strong&gt;非对称加密：&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;In an asymmetric encryption algorithm, there are different encryption and
decryption keys…. Any sender can use that key to encrypt a communication,
but only the key creator can decrypt the communication. This scheme, known
as public-key encryption, was a breakthrough in cryptography.
在非对称加密算法，加密和解密密钥是不同的。…任何发送者能均够能使用那个密钥 （即公钥）加密通讯，但是只有密匙创建者能解密通讯。这种模式，被称为公钥加密，曾是密码学的一个突破。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;example-rsa-algorithm-rsa-&quot;&gt;&lt;strong&gt;Example: RSA Algorithm 举例：RSA 加密算法&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;In RSA, k&lt;sub&gt;e&lt;/sub&gt;  is the public key, and k&lt;sub&gt;d&lt;/sub&gt;  is the private key. N is the product of
two large, randomly chosen prime numbers p and q (for example, p and q are
512 bits each). It must be computationally infeasible to derive k&lt;sub&gt;d,N&lt;/sub&gt;  from k&lt;sub&gt;e,N&lt;/sub&gt; , so
that k&lt;sub&gt;e&lt;/sub&gt;  need not be kept secret and can be widely disseminated. The encryption
algorithm is E&lt;sub&gt;k&lt;sub&gt;e&lt;/sub&gt;&lt;/sub&gt; ,N(m) = mk&lt;sub&gt;e&lt;/sub&gt; mod N, where k&lt;sub&gt;e&lt;/sub&gt;  satisfies k&lt;sub&gt;e&lt;/sub&gt; k&lt;sub&gt;d&lt;/sub&gt;  mod (p−1)(q−1) =1. The decryption algorithm is then D&lt;sub&gt;k&lt;sub&gt;d&lt;/sub&gt;&lt;/sub&gt;  ,N(c) = ck&lt;sub&gt;d&lt;/sub&gt;  mod N.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在RSA中，k&lt;sub&gt;e&lt;/sub&gt; 是公钥，k&lt;sub&gt;d&lt;/sub&gt; 是私钥, N是两个较大的随机选择的素数之积（比如，p,q每个都是512位长）。从k&lt;sub&gt;d,N&lt;/sub&gt; 到k&lt;sub&gt;e,N&lt;/sub&gt; 一定是不能计算出的,因此k&lt;sub&gt;e&lt;/sub&gt; 不必保持机密并可以被广泛传播。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;加密算法是E&lt;sub&gt;k&lt;sub&gt;e&lt;/sub&gt;&lt;/sub&gt; , N(m) = m&lt;sup&gt;k&lt;sub&gt;e&lt;/sub&gt;&lt;/sup&gt; mod N,k&lt;sub&gt;e&lt;/sub&gt; 满足 k&lt;sub&gt;e&lt;/sub&gt; k&lt;sub&gt;d&lt;/sub&gt; mod (p−1)(q−1) = 1.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;接着解密算法是 D&lt;sub&gt;k&lt;sub&gt;d&lt;/sub&gt;&lt;/sub&gt; ，N(c) = c&lt;sup&gt;k&lt;sub&gt;d&lt;/sub&gt;&lt;/sup&gt;mod N&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;An example using small values is shown in Figure 15.8. In this example, we
make p = 7 and q = 13.We then calculate N = 7∗13 = 91 and (p−1)(q−1) = 72.
We next select k&lt;sub&gt;e&lt;/sub&gt;  relatively prime to 72 and &amp;lt; 72, yielding 5. Finally, we calculate
k&lt;sub&gt;d&lt;/sub&gt;  such that k&lt;sub&gt;e&lt;/sub&gt; k&lt;sub&gt;d&lt;/sub&gt;  mod 72 = 1, yielding 29. We now have our keys: the public
key, k&lt;sub&gt;e&lt;/sub&gt; ,N = 5, 91, and the private key, k&lt;sub&gt;d&lt;/sub&gt; ,N = 29, 91. Encrypting the message 69
with the public key results in the message 62, which is then decoded by the
receiver via the private key.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/img/2016-05-29-os-notes-chapter-15/15.8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;图15.8一个比较小一点的例子。我们让 p = 7, q =13。然后计算N = 7*13 且 (p−1)(q−1) = 72。接着我们相应的给k&lt;sub&gt;e&lt;/sub&gt;选择一个小于72的素数，得到5。最后我们通过k&lt;sub&gt;e&lt;/sub&gt; k&lt;sub&gt;d&lt;/sub&gt; mod 72=1计算得到 k&lt;sub&gt;d&lt;/sub&gt; ，为29。因此现在k&lt;sub&gt;e&lt;/sub&gt;,N = 5, 91；私钥 k&lt;sub&gt;d&lt;/sub&gt; ,N = 29, 91。用公钥加密消息69得到密文结果62,然后通过私钥解密。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;RSA 算法： 数学知识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关于RSA算法用到的数学知识，请参见&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot;&gt;阮一峰大神的教程I(前置数学知识)&lt;/a&gt;
  及
  &lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot;&gt;阮一峰大神的教程II（最后一部分:算法正确性的证明)&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The use of asymmetric encryption begins with the publication of the public
key of the destination. For bidirectional communication, the source also must
publish its public key. “Publication” can be as simple as handing over an
electronic copy of the key, or it can be more complex. The private key (or “secret
key”) must be zealously guarded, as anyone holding that key can decrypt any
message created by the matching public key.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;非对称加密的使用从公钥的发布开始。对于双向通信，消息源还必须发布它的公钥 &lt;em&gt;（译者注：注意直接把公钥发布出去会出问题，下面会提到）&lt;/em&gt;。发布可以简单的像传递这个公钥的电子拷贝一样，也可以使得它变得更复杂一点。私钥必须被积极保护起来。因为任何持有这个私钥的人，都可以解密由和这个私钥相匹配的那个公钥加密的任何信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We should note that the seemingly small difference in key use between
asymmetric and symmetric cryptography is quite large in practice. Asymmetric
cryptography is much more computationally expensive to execute. It is much
faster for a computer to encode and decode ciphertext by using the usual
symmetric algorithms than by using asymmetric algorithms. Why, then, use
an asymmetric algorithm? In truth, these algorithms are not used for general purpose
encryption of large amounts of data. However, they are used not
only for encryption of small amounts of data but also for authentication,
confidentiality, and key distribution, as we show in the following sections.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们应该注意到非对称加密和对称加密在密钥使用上的微小不同其实导致在实践中二者的差别是非常大的。非对称加密计算会消耗更多的资源。通常来说，使用对称加密和解密密文比非对称加密密文更快。那么为啥我们还要用非对称加密算法呢？事实上，这些（非对称加密）算法不是为通常意义上大量数据的加密而准备的。非对称加密不仅仅被使用在少量数据的加密中也被使用在验证，保密和密钥分发的过程，就像下面几个小节所述的一样。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;authentication&quot;&gt;&lt;strong&gt;Authentication认证&lt;/strong&gt;&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;We have seen that encryption offers a way of constraining the set of possible
receivers of a message. Constraining the set of potential senders of a message
is called authentication. Authentication is thus complementary to encryption.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;加密可以提供一种限制信息接受者范围的途径（译者注：即有密钥(非对称中是私钥)才能解密没有则不能）。限制信息的发送者范围叫做验证。验证是加密的补充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Authentication is also useful for proving that a message has not been modified.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;验证也能确保信息不被更改。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;An authentication algorithm using symmetric keys consists of the following
components:
 + A set K of keys.
 + A set M of messages.
 + A set A of authenticators.
 + A function S : K → (M → A). That is, for each k ∈ K, S&lt;sub&gt;k&lt;/sub&gt;  is a function for
generating authenticators from messages. Both S and S&lt;sub&gt;k&lt;/sub&gt;  for any k should
be efficiently computable functions.
 + A function V : K → (M×A→{true, false}). That is, for each k ∈ K, V&lt;sub&gt;k&lt;/sub&gt;
is a function for verifying authenticators on messages. Both V and V&lt;sub&gt;k&lt;/sub&gt;  for
any k should be efficiently computable functions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用对称密钥的认证算法由下面的部分构成：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一个密钥集合K&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一个消息集合M&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一个验证器集合A&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一个验证器生成函数 S : K → (M→A). 即，对于每个密钥 k ∈ K, S&lt;sub&gt;k&lt;/sub&gt; 是一个用消息生成验证器的函数。对任意k来说， S和S&lt;sub&gt;k&lt;/sub&gt; 都是高效的且可计算的函数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;一个验证器验证函数 E : K → (M×A→{true, false}). 即，对于每个密钥 k ∈ K, V&lt;sub&gt;k&lt;/sub&gt; 是一个用来验证特定消息的验证器的函数。对任意k来说， V 和V&lt;sub&gt;k&lt;/sub&gt;  都是高效的且可计算的函数。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The critical property that an authentication algorithm must possess is this:
for a message m, a computer can generate an authenticator a ∈ A such
that V&lt;sub&gt;k&lt;/sub&gt;  (m, a) = true only if it possesses k. Thus, a computer holding k can generate authenticators on messages so that any computer possessing k can
verify them. However, a computer not holding k cannot generate authenticators
on messages that can be verified using V&lt;sub&gt;k&lt;/sub&gt; . Since authenticators are generally
exposed (for example, sent on a network with the messages themselves), it
must not be feasible to derive k from the authenticators. Practically, if V&lt;sub&gt;k&lt;/sub&gt;  (m, a)
= true, then we know that m has not been modified, and that the sender of
the message has k. If we share k with only one entity, then we know that the
message originated from k.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;验证算法的重要属性是：** 对一个消息m,只有计算机掌握k的时候可以生成一个验证器 a ∈ A 使得验证函数 V&lt;sub&gt;k&lt;/sub&gt; (m, a) = true 。** 因此，任何持有密钥k的计算机可以生成关于消息m的验证器，这个验证器可被其它任意一台任何持有密钥k的计算机通过V&lt;sub&gt;k&lt;/sub&gt; 来验证。因为验证器通常是被暴露的（比如，在网络上和消息一起被发送），所以很重要的一点是让从验证器推出密钥k变得不可能。实际上，如果V&lt;sub&gt;k&lt;/sub&gt; (m, a) = true,我们就可以知道消息没被更改过。如果我们只把k分享给过一个实体，那么我们就能知道消息源自最初的发布者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Just as there are two types of encryption algorithms, there are two main varieties of authentication algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;和两种加密算法相同，也有两种认证算法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;hash&quot;&gt;&lt;strong&gt;Hash函数&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The first step in understanding these algorithms is to explore hash functions. A hash function H(m) creates a small, fixed-sized block of data, known as a message digest or hash value, from a message m. Hash functions work by taking a message, splitting it into blocks, and processing the blocks to produce an n-bit hash. H must be collision resistant —that is, it must be infeasible to find an m&lt;sup&gt;’&lt;/sup&gt;  = m such that H(m) = H(m&lt;sup&gt;’&lt;/sup&gt;  ). Now, if H(m) = H(m&lt;sup&gt;’&lt;/sup&gt; ), we know that m = m&lt;sup&gt;’&lt;/sup&gt;  — that is, we know that the message has not been modified. Common message-digest functions include MD5, now considered insecure, which produces a 128-bit hash, and SHA-1, which outputs a 160-bit hash. Message digests are useful for detecting changed messages but are not useful as authenticators. For example, H(m) can be sent along with a
message; but if H is known, then someone could modify m to m&lt;sup&gt;’&lt;/sup&gt;  and recompute H(m&lt;sup&gt;’&lt;/sup&gt;  ), and the message modification would not be detected. Therefore, we must authenticate H(m).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;理解这两种算法的第一步是探索hash函数。hash函数H(m)用一条消息创建一块小的且固定大小的数据，被称作消息摘要或者hash值。它是这样工作的：取一条消息,将其拆分成块，并且处理这些小块来产生n位的hash。H函数是拒绝碰撞的，也就是说，如果m&lt;sup&gt;’&lt;/sup&gt; =m，则H(m) = H(m&lt;sup&gt;’&lt;/sup&gt;   ) 是不成立的。所以现在，如果H(m) = H(m&lt;sup&gt;’&lt;/sup&gt;   ), 那么一定有m =  m&lt;sup&gt;’&lt;/sup&gt;  ，也就是说，我们可以确定这条消息m没有被更改。常见的消息摘要函数包括产生128位hash摘要的MD5（现在已经被认为是不安全的）和产生160位hash摘要的SHA-1。消息摘要对检测消息是否被更改十分有用但是对验证验证器来说是没用的。比如，H(m)可以和一条消息一起被发送，但是如果H函数是已知的其他人可以将m修改成m&lt;sup&gt;’&lt;/sup&gt;  然后重新计算H(m&lt;sup&gt;’&lt;/sup&gt;  ),并且这种更改不能被检测出来。因此，我们必须验证H(m).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;message-authentication-code-mac&quot;&gt;&lt;strong&gt;message-authentication code (MAC)消息验证码&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;uses symmetric encryption 使用对称加密&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;a cryptographic checksum is generated from the message using a secret key 消息的加密校验和通过一个密钥来被生成。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;k is needed to compute both S&lt;sub&gt;k&lt;/sub&gt;  andV&lt;sub&gt;k&lt;/sub&gt; , so anyone able to compute one can compute the other. k用来计算S&lt;sub&gt;k&lt;/sub&gt; 和V&lt;sub&gt;k&lt;/sub&gt; ,所以任何能计算一个的人也能计算另外一个。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;digital-signature-algorithm&quot;&gt;&lt;strong&gt;digital-signature algorithm数字签名算法&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;the authenticators thus produced are called digital signatures 这种算法的验证器也被叫做数字签名。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Digital signatures are very useful in that they enable anyone to verify the authenticity of the message.数字签名使得任何人可以验证消息的真实性。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;k&lt;sub&gt;v&lt;/sub&gt;  is the public key, and k&lt;sub&gt;s&lt;/sub&gt;  is the private key. k&lt;sub&gt;v&lt;/sub&gt; 是公钥，k&lt;sub&gt;s&lt;/sub&gt; 是私钥。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;infeasible to derive k&lt;sub&gt;s&lt;/sub&gt;  from k&lt;sub&gt;v&lt;/sub&gt;  不可从k&lt;sub&gt;v&lt;/sub&gt; 推导出k&lt;sub&gt;s&lt;/sub&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Example: RSA digital-signature algorithm&lt;/strong&gt; ，similar to the RSA encryption algorithm, but the key use is reversed. The digital signature of a message is derived by computing S&lt;sub&gt;k&lt;sub&gt;s&lt;/sub&gt;&lt;/sub&gt; (m) = H(m)&lt;sup&gt;k&lt;sub&gt;s&lt;/sub&gt;&lt;/sup&gt;  mod N.The key k&lt;sub&gt;s&lt;/sub&gt;  again is a pair &amp;lt;d, N&amp;gt;, where N is the product of two large, randomly chosen prime numbers p and q. The verification algorithm is then
V&lt;sub&gt;k&lt;sub&gt;v&lt;/sub&gt;&lt;/sub&gt; = ?  ( a&lt;sup&gt;k&lt;sub&gt;v&lt;/sub&gt;&lt;/sup&gt;  mod N = H(m)), where k&lt;sub&gt;v&lt;/sub&gt;  satisfies k&lt;sub&gt;v&lt;/sub&gt; k&lt;sub&gt;s&lt;/sub&gt; mod (p − 1)(q − 1) = 1.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;例子：RSA 数字签名算法, 和RSA加密算法类似，但是key的使用是相反的(译者注：即私钥算出验证器，公钥验证验证器)。一个消息的数字签名S&lt;sub&gt;k&lt;sub&gt;s&lt;/sub&gt;&lt;/sub&gt; (m)是通过计算S&lt;sub&gt;k&lt;sub&gt;s&lt;/sub&gt;&lt;/sub&gt; (m) =H(m)&lt;sup&gt;k&lt;sub&gt;s&lt;/sub&gt;&lt;/sup&gt; mod N 得到的。密钥k&lt;sub&gt;s&lt;/sub&gt; 同样是有序数对&amp;lt;d,N&amp;gt;,N同样是两个巨大的且随机选出的素数p和q之积。验证算法是V&lt;sub&gt;k&lt;sub&gt;v&lt;/sub&gt;&lt;/sub&gt; = ? ( a&lt;sup&gt;k&lt;sub&gt;v&lt;/sub&gt;&lt;/sup&gt;  mod N =H(m)),同样k&lt;sub&gt;v&lt;/sub&gt; 满足k&lt;sub&gt;v&lt;/sub&gt; k&lt;sub&gt;s&lt;/sub&gt;  mod (p − 1)(q − 1) = 1.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;（先写到这里好了，时间有限，回来将后面SSL的部分补上。）&lt;/p&gt;
</description>
        <pubDate>Sun, 29 May 2016 14:30:00 +0800</pubDate>
        <link>http://shellcottage.me/os-notes-chapter-15/</link>
        <guid isPermaLink="true">http://shellcottage.me/os-notes-chapter-15/</guid>
        
        <category>加密</category>
        
        <category>验证</category>
        
        <category>笔记</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>(For test purpose)你好 Blog</title>
        <description>&lt;p&gt;(This is an test article)
说起来，已经有多久没有用中文写过大于四百字的文章了？ 记得高三的时候对文字兴趣可大了，当时每到自习课我都要写黄文，一写就能写好几张， 现在反而没有当时那种劲头了。 想起来从那时起，已经很久没有写一些记录性的东西了，中间在新浪更过两篇，QQ更过两篇，又感觉太过矫情，删掉了。所以跑到Github pages来更这个博客， 就像是一个归档一样的东西，不然以后想起来这两年干了啥， 不要只想到赶不完的 deadline ， 做不完的视频，以及总是用完的卷纸，感觉这样有点荒废。&lt;/p&gt;
</description>
        <pubDate>Fri, 29 Jan 2016 08:00:00 +0800</pubDate>
        <link>http://shellcottage.me/hello-blog/</link>
        <guid isPermaLink="true">http://shellcottage.me/hello-blog/</guid>
        
        <category>fuck</category>
        
        <category>record</category>
        
        <category>jekyll</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
